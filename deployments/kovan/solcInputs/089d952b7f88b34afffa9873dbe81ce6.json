{
  "language": "Solidity",
  "sources": {
    "contracts/Assets.sol": {
      "content": "/*\n* LibertyPie Project (https://libertypie.com)\n* @author https://github.com/libertypie (hello@libertypie.com)\n* @license SPDX-License-Identifier: MIT\n*/\npragma solidity ^0.7.6;\npragma experimental ABIEncoderV2;\n\n//import \"./PermissionManager/PM.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\n//import \"./Storage/StoreProxy.sol\";\nimport \"./Commons/AssetsStructs.sol\";\nimport \"./Base.sol\";\nimport \"./PriceFeeds/PriceFeed.sol\";\n\ncontract Assets is Base {\n\n    //events \n    event AddAsset(uint256 id);\n    event UpdateAsset(uint256 id);\n\n    //store Proxy\n    ////IStorage getDataStore() = StoreProxy(address(this)).getIStorage();\n\n    //initiate price feed\n    PriceFeed _priceFeed = PriceFeed(address(this));\n\n     /**\n     * @dev add a new asset to supported list\n     * @param  contractAddress asset's contract address\n     * @param  isPegged a  boolean describing wether its pegged  or not\n     * @param  peggedAssetGateway gateway for interacting with the asset\n     * @param  originalName if pegged, then original asset name\n     * @param  originalSymbol if pegged, the original symbol\n     * @param isEnabled if contract is enabled\n     */\n    function addAsset(\n        address           contractAddress, \n        bool              isPegged,\n        address           peggedAssetGateway,\n        string   memory   originalName,\n        string   memory   originalSymbol,\n        string   memory   priceFeedProvider,\n        address           priceFeedContract,\n        bool              isEnabled\n    ) public onlyAdmin returns(uint256) {\n        \n        //fetch contract  info\n        ERC20 erc20Token = ERC20(contractAddress);\n\n        uint256 id = getDataStore().getNextAssetId();\n\n        AssetsStructs.AssetItem memory assetItem = AssetsStructs.AssetItem(\n            id,\n            contractAddress,\n            erc20Token.decimals(),\n            isPegged,\n            peggedAssetGateway,\n            originalName,\n            originalSymbol,\n            priceFeedProvider,\n            priceFeedContract,\n            isEnabled,\n            block.timestamp,\n            block.timestamp\n        );\n\n        processAndSaveAsset(assetItem, erc20Token.symbol());\n\n        emit AddAsset(id);\n\n        return id;\n    }//end fun\n\n\n    /**\n     * @dev add a new asset to supported list\n     * @param id asset Id\n     * @param contractAddress asset's contract address\n     * @param isPegged a  boolean describing wether its pegged  or not\n     * @param peggedAssetGateway the pegged asset gateway\n     * @param originalName if pegged, then original asset name\n     * @param originalSymbol if pegged, the original symbol\n     * @param isEnabled if contract is enabled\n     */\n    function updateAsset(\n        uint256             id,\n        address             contractAddress, \n        bool                isPegged,\n        address             peggedAssetGateway,\n        string    memory    originalName,\n        string    memory    originalSymbol,\n        string    memory    priceFeedProvider,\n        address             priceFeedContract,\n        bool                isEnabled\n    )  public onlyAdmin returns(uint256) {\n\n\n        //lets get the assetInfo\n        AssetsStructs.AssetItem memory assetInfo = getAssetById(id);\n\n        require(assetInfo.contractAddress != address(0), statusMsg(\"UNKNOWN_ASSET\"));\n\n        //fetch contract  info\n        ERC20 erc20Token = ERC20(contractAddress);\n\n        AssetsStructs.AssetItem memory newAssetItem = AssetsStructs.AssetItem(\n            id,\n            contractAddress,\n            erc20Token.decimals(),\n            isPegged,\n            peggedAssetGateway,\n            originalName,\n            originalSymbol,\n            priceFeedProvider,\n            priceFeedContract,\n            isEnabled,\n            assetInfo.createdAt,\n            block.timestamp\n        );\n\n\n        processAndSaveAsset(newAssetItem, erc20Token.symbol());\n      \n        emit UpdateAsset(id);\n\n        return id;\n    }//end \n\n\n    /**\n     * @dev process and save asset\n     */\n    function processAndSaveAsset(\n        AssetsStructs.AssetItem memory assetItem,\n        string memory assetSymbol \n    ) private onlyAdmin  {\n\n        uint256 totalAssets = getDataStore().getTotalAssets();\n\n        require(assetItem.id > 0 && assetItem.id <= totalAssets, statusMsg(\"INVALID_ASSET_ID\"));\n\n        require(assetItem.contractAddress != address(0), statusMsg(\"INAVLID_CONTRACT_ADDRESS\"));\n\n        require(assetItem.priceFeedContract != address(0), statusMsg(\"INAVLID_PRICE_FEED_CONTRACT_ADDRESS\"));\n\n        require(assetItem.contractAddress != address(0), statusMsg(\"INVALID_ASSET_CONTRACT_ADDRESS\"));\n\n        _priceFeed.setAssetPriceFeedContract(assetSymbol, assetItem.priceFeedContract);\n        \n        // lets save the data\n        getDataStore().saveAssetData(assetItem.id, assetItem);\n\n    }//end\n   \n    /**\n     * @dev fetch asset by it contract address\n     * @param _contractAddress asset's contract address\n     * @return AssetsStructs.AssetItem\n     */\n    function getAsset(address _contractAddress) public  view returns (AssetsStructs.AssetItem memory) {\n        \n        //first lets get the index\n        uint256 assetId = getDataStore().getAssetIdByAddress(_contractAddress);\n\n\n        //this lets check if id isnt 0\n        require(assetId > 0, \"XPIE:UNKNOWN_ASSET\");\n\n\n        //lets get asset info by id\n        AssetsStructs.AssetItem memory assetData = getAssetById(assetId);\n\n        //is asset enabled, if not disabled \n        require(assetData.isEnabled == true,\"XPIE:ASSET_NOT_ENABLED\");\n        \n        return assetData;\n    } //end \n\n\n    /**\n     * @dev getAssetById\n     * @param _id asset id\n     */\n    function getAssetById(uint256 _id) public view returns (AssetsStructs.AssetItem memory) {\n        return getDataStore().getAssetData(_id);\n    }\n\n\n    /**\n     * @dev check if the asset is valid or enabled \n     */\n    function isValidAssetItem(AssetsStructs.AssetItem memory assetItem) pure internal  returns(bool){\n        return (\n            assetItem.contractAddress != address(0) && \n            assetItem.isEnabled == true\n        );\n    }\n\n    /**\n     * isValidAsset using id\n     * @param _id asset id\n     */\n    function isValidAssetItem(uint256 _id) public view returns(bool) {\n        return isValidAssetItem(getAssetById(_id));\n    }\n\n\n    /**\n     * @dev is the provided asset contract supported\n     *  @param _contractAddress  asset contract address\n     */\n     function isAssetSupported(address _contractAddress) public  view returns(bool) {\n         return isValidAssetItem(getAsset(_contractAddress));\n     }\n\n\n    /**\n     * @dev get all assets \n     */\n     function getAllAssets() public view returns(AssetsStructs.AssetItem[] memory){\n\n        uint256 totalAssets = getDataStore().getTotalAssets();\n\n        AssetsStructs.AssetItem[] memory assetsData  = new AssetsStructs.AssetItem[]  (totalAssets + 1);\n\n         //loop to get items\n         // ids never starts  with  0, so start with  1\n        for(uint256 i = 1; i <= totalAssets; i++){\n\n             //lets now get asset  info \n            AssetsStructs.AssetItem memory assetItem = getAssetById(i);\n\n            if(isValidAssetItem(assetItem)){\n                assetsData[i] = assetItem;\n            }\n        }\n\n        return assetsData;\n     } //end fun\n\n\n} //end contract"
    },
    "@openzeppelin/contracts/token/ERC20/ERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\nimport \"../../utils/Context.sol\";\nimport \"./IERC20.sol\";\nimport \"../../math/SafeMath.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * We have followed general OpenZeppelin guidelines: functions revert instead\n * of returning `false` on failure. This behavior is nonetheless conventional\n * and does not conflict with the expectations of ERC20 applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20 is Context, IERC20 {\n    using SafeMath for uint256;\n\n    mapping (address => uint256) private _balances;\n\n    mapping (address => mapping (address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n    uint8 private _decimals;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}, initializes {decimals} with\n     * a default value of 18.\n     *\n     * To select a different value for {decimals}, use {_setupDecimals}.\n     *\n     * All three of these values are immutable: they can only be set once during\n     * construction.\n     */\n    constructor (string memory name_, string memory symbol_) public {\n        _name = name_;\n        _symbol = symbol_;\n        _decimals = 18;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5,05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the value {ERC20} uses, unless {_setupDecimals} is\n     * called.\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual returns (uint8) {\n        return _decimals;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `recipient` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\n        _transfer(_msgSender(), recipient, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        _approve(_msgSender(), spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * Requirements:\n     *\n     * - `sender` and `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``sender``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {\n        _transfer(sender, recipient, amount);\n        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, \"ERC20: transfer amount exceeds allowance\"));\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, \"ERC20: decreased allowance below zero\"));\n        return true;\n    }\n\n    /**\n     * @dev Moves tokens `amount` from `sender` to `recipient`.\n     *\n     * This is internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `sender` cannot be the zero address.\n     * - `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     */\n    function _transfer(address sender, address recipient, uint256 amount) internal virtual {\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(sender, recipient, amount);\n\n        _balances[sender] = _balances[sender].sub(amount, \"ERC20: transfer amount exceeds balance\");\n        _balances[recipient] = _balances[recipient].add(amount);\n        emit Transfer(sender, recipient, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply = _totalSupply.add(amount);\n        _balances[account] = _balances[account].add(amount);\n        emit Transfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        _balances[account] = _balances[account].sub(amount, \"ERC20: burn amount exceeds balance\");\n        _totalSupply = _totalSupply.sub(amount);\n        emit Transfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Sets {decimals} to a value other than the default one of 18.\n     *\n     * WARNING: This function should only be called from the constructor. Most\n     * applications that interact with token contracts will not expect\n     * {decimals} to ever change, and may work incorrectly if it does.\n     */\n    function _setupDecimals(uint8 decimals_) internal virtual {\n        _decimals = decimals_;\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be to transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual { }\n}\n"
    },
    "contracts/Commons/AssetsStructs.sol": {
      "content": "/*\n* LibertyPie Project (https://libertypie.com)\n* @author https://github.com/libertypie (hello@libertypie.com)\n* @license SPDX-License-Identifier: MIT\n*/\npragma solidity ^0.7.6;\npragma experimental ABIEncoderV2;\n\n/**\n * @dev assets struct Implementation\n */\ncontract AssetsStructs {\n    \n    /**\n     * @dev asset struct item\n     */\n    struct AssetItem {\n        uint256   id;\n        address   contractAddress;\n        uint8     decimals;\n        bool      isPegged;\n        address   peggedAssetGateway;\n        string    originalName;\n        string    originalSymbol;\n        string    priceFeedProvider;\n        address   priceFeedContract;\n        bool      isEnabled;\n        uint256   createdAt;\n        uint256   updatedAt;\n    }\n\n}"
    },
    "contracts/Base.sol": {
      "content": "/*\n* LibertyPie Project (https://libertypie.com)\n* @author https://github.com/libertypie (hello@libertypie.com)\n* @license SPDX-License-Identifier: MIT\n*/\npragma solidity ^0.7.6;\npragma experimental ABIEncoderV2;\n\nimport \"./Config.sol\";\n\ncontract Base is  Config {}"
    },
    "contracts/PriceFeeds/PriceFeed.sol": {
      "content": "/*\n* LibertyPie Project (https://libertypie.com)\n* @author https://github.com/libertypie (hello@libertypie.com)\n* @license SPDX-License-Identifier: MIT\n*/\npragma solidity ^0.7.6;\npragma experimental ABIEncoderV2;\n\nimport \"./Oracles/IPriceFeed.sol\";\nimport \"./Oracles/ChainLink.sol\";\nimport \"./Oracles/OpenPriceFeed.sol\";\nimport \"../Base.sol\";\n\ncontract PriceFeed is Base, ChainLink {\n\n   /*\n   event SetAssetPriceFeedContract( string indexed _assset, address indexed _contract);\n\n   IPriceFeed ACTIVE_PRICE_FEED_PROVIDER;\n   \n   string ACTIVE_PRICE_FEED_PROVIDER_NAME;\n\n   mapping(string => address) public priceFeedOracles;\n\n\n   constructor() {\n\n      address chainLinkAddress = address(new ChainLink());\n\n      //create the price feed oracles\n      priceFeedOracles[\"chainlink\"] = chainLinkAddress;\n      priceFeedOracles[\"open_price_feed\"] = address(new OpenPriceFeed());\n\n      //set active contract \n      ACTIVE_PRICE_FEED_PROVIDER = IPriceFeed(chainLinkAddress);\n      ACTIVE_PRICE_FEED_PROVIDER_NAME = \"chainlink\";\n   }\n\n\n   /**\n    * @dev chang provider\n    * @param _provider (example chainlink)\n    *\n    function priceFeedSetActiveProvider(string memory _provider)  public onlyAdmin {\n\n      require(toBytes32(_provider) == toBytes32(\"chainlink\") || \n              toBytes32(_provider) == toBytes32(\"open_price_feed\"),\n              statusMsg(\"UNKNOWN_PROVIDER\",_provider)\n      );\n\n      address _providerContractAddr = priceFeedOracles[_provider];\n\n      require(_providerContractAddr != address(0),statusMsg(\"PROVIDER_CONTRACT_ADDRESS_INVALID\"));\n\n      ACTIVE_PRICE_FEED_PROVIDER = IPriceFeed(_providerContractAddr);\n\n      ACTIVE_PRICE_FEED_PROVIDER_NAME = _provider;\n    } //end fun \n\n\n   /**\n    * @dev get latest price\n    * @param _asset asset symbol\n    *\n   function getLatestPrice(string memory _asset) public view returns (uint256) {\n      return ACTIVE_PRICE_FEED_PROVIDER.getLatestPrice(_asset);\n   } //end fun \n\n\n   /**\n    * get latestPrice by provider\n    * @param  _provider provider name eg. chainlink\n    * @param _asset  asset symbol eg. eth\n    *\n    function getLatestPriceByProvider(string memory _provider,string memory _asset) public view returns (uint256) {\n      \n      require(toBytes32(_provider) == toBytes32(\"chainlink\") || \n         toBytes32(_provider) == toBytes32(\"open_price_feed\"),\n         statusMsg(\"UNKNOWN_PROVIDER\",_provider)\n      );\n\n      address _providerContractAddr = priceFeedOracles[_provider];\n\n      require(_providerContractAddr != address(0),statusMsg(\"PROVIDER_CONTRACT_ADDRESS_INVALID\"));\n\n      IPriceFeed _providerContract = IPriceFeed(_providerContractAddr);\n\n      return _providerContract.getLatestPrice(_asset);\n    } //end fun \n\n    /**\n     * @dev set priceFeed contract\n     * @param _asset the asset  to fetch price feed\n     * @param _contract feed contract\n     *\n    function setAssetPriceFeedContract(string memory _asset, address _contract) public onlyAdmin {\n      ACTIVE_PRICE_FEED_PROVIDER.setAssetPriceFeedContract(_asset,_contract);\n      emit SetAssetPriceFeedContract(_asset,_contract);\n    }\n    */\n\n}  //end contract "
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\n/*\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with GSN meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address payable) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes memory) {\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n        return msg.data;\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"
    },
    "@openzeppelin/contracts/math/SafeMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        uint256 c = a + b;\n        if (c < a) return (false, 0);\n        return (true, c);\n    }\n\n    /**\n     * @dev Returns the substraction of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        if (b > a) return (false, 0);\n        return (true, a - b);\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) return (true, 0);\n        uint256 c = a * b;\n        if (c / a != b) return (false, 0);\n        return (true, c);\n    }\n\n    /**\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        if (b == 0) return (false, 0);\n        return (true, a / b);\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        if (b == 0) return (false, 0);\n        return (true, a % b);\n    }\n\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b <= a, \"SafeMath: subtraction overflow\");\n        return a - b;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     *\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (a == 0) return 0;\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b > 0, \"SafeMath: division by zero\");\n        return a / b;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b > 0, \"SafeMath: modulo by zero\");\n        return a % b;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {trySub}.\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        return a - b;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryDiv}.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b > 0, errorMessage);\n        return a / b;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting with custom message when dividing by zero.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryMod}.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b > 0, errorMessage);\n        return a % b;\n    }\n}\n"
    },
    "contracts/Config.sol": {
      "content": "/*\n* LibertyPie Project (https://libertypie.com)\n* @author https://github.com/libertypie (hello@libertypie.com)\n* @license SPDX-License-Identifier: MIT\n*/\npragma solidity ^0.7.6;\npragma experimental ABIEncoderV2;\n\nimport \"./PermissionManager/PM.sol\";\nimport \"./Commons/ConfigsStructs.sol\";\nimport \"./Utils.sol\";\n//import \"./Storage/Interfaces/IStorage.sol\";\nimport \"./Storage/DataStore.sol\";\n\ncontract Config is PM, Utils, DataStore {\n\n    /**\n     * get config\n     * @param _key config key \n     */ \n    function getConfig(string memory _key) public view returns(bytes32) {\n        return getDataStore().getConfigData(_key);\n    }\n\n    \n    /**\n     * setConfig\n     * @param _key config key\n     * @param _value cofig data\n     */\n    function setConfigData(string memory _key, bytes32 _value) public onlyAdmin {\n        getDataStore().addConfigData(_key, _value);\n    }\n\n\n    /**\n     * get all config data\n     */\n    function getAllConfigs() public view returns (ConfigsStructs.ConfigItem[] memory){\n       return  getDataStore().getAllConfigData();\n    }\n\n}"
    },
    "contracts/PermissionManager/PM.sol": {
      "content": "/*\n* LibertyPie Project (https://libertypie.com)\n* @author https://github.com/libertypie (hello@libertypie.com)\n* @license SPDX-License-Identifier: MIT\n*/\npragma solidity ^0.7.6;\n\n\ninterface IPermissionManager {\n    function isSuperAdmin(address _address) external view  returns(bool);\n    function isAdmin(address _address) external view  returns(bool);\n    function isModerator(address _address) external view returns(bool);\n    function isStorageEditor(address _address) external view  returns(bool);\n    function hasRole(string memory roleName, address _address) external view returns (bool);\n    function grantRole(string memory roleName, address _address) external;\n}\n\ncontract PM {\n\n    event SetPermissionManager(address indexed _contract);\n\n    IPermissionManager public PERMISSION_MANAGER;\n\n    bool pmInitialized;\n    \n    address _owner;\n\n    constructor() {\n      _owner = msg.sender;\n    }\n\n    /**\n     * initializePM\n     */\n    function initializePermissionManager(address _permissionManager) internal {\n      \n      require(!pmInitialized, \"PERMISSION_MANAGER_ALREADY_INITIALIZED\");\n\n      require(_owner == msg.sender, \"ONLY_CONTRACT_OWNER_CAN_INITIALIZE\");\n      \n      PERMISSION_MANAGER = IPermissionManager(_permissionManager);\n\n      //lets add contract as permitted to write on storage \n      //PERMISSION_MANAGER.grantRole(\"STORAGE_EDITOR\", address(this));\n\n      emit SetPermissionManager(_permissionManager);\n\n      pmInitialized = true;\n    }\n\n   \n    /**\n     * @dev  set permission manager contract\n     */\n    function setPermissionManager(address _newAddress) external onlySuperAdmin () {\n      \n      PERMISSION_MANAGER = IPermissionManager(_newAddress);\n\n      emit SetPermissionManager(_newAddress);\n    }\n\n    /**\n    * @dev superAdminOnly - a modifier which allows only super admin \n    */\n    modifier onlySuperAdmin () {\n      require(PERMISSION_MANAGER.isSuperAdmin(msg.sender), \"ONLY_SUPER_ADMINS_ALLOWED\" );\n      _;\n    }\n\n    /**\n    * OnlyAdmin \n    * This also allows super admins\n    */\n    modifier onlyAdmin () {\n      require(PERMISSION_MANAGER.isAdmin(msg.sender), \"ONLY_ADMINS_ALLOWED\");\n      _;\n    }\n\n    /**\n    * OnlyModerator\n    */\n    modifier onlyModerator() {\n      require(PERMISSION_MANAGER.isModerator(msg.sender), \"MODERATORS_ONLY_ALLOWED\" );\n      _;\n    }\n\n   \n    /**\n     * hasRole\n     */\n    function hasRole(string memory roleName, address _address) public view returns(bool){\n      return PERMISSION_MANAGER.hasRole(roleName,_address);\n    }\n\n\n    /**\n     * grant role\n     */\n    function grantRole(string memory roleName, address _address) public onlySuperAdmin {\n      PERMISSION_MANAGER.grantRole(roleName, _address);\n    }\n\n} //end function"
    },
    "contracts/Commons/ConfigsStructs.sol": {
      "content": "/*\n* LibertyPie Project (https://libertypie.com)\n* @author https://github.com/libertypie (hello@libertypie.com)\n* @license SPDX-License-Identifier: MIT\n*/\npragma solidity ^0.7.6;\npragma experimental ABIEncoderV2;\n\n/**\n * @dev offer struct Implementation\n */\ncontract ConfigsStructs {\n\n    struct ConfigItem {\n        string _key;\n        bytes32 _value;\n    }\n}"
    },
    "contracts/Utils.sol": {
      "content": "/*\n* LibertyPie Project (https://libertypie.com)\n* @author https://github.com/libertypie (hello@libertypie.com)\n* @license SPDX-License-Identifier: MIT\n*/\npragma solidity ^0.7.6;\npragma experimental ABIEncoderV2;\n\n\ncontract Utils {\n\n    /**\n     * @dev get chain id\n     */\n    function getChainID() public view returns (uint256) {\n        uint256 id;\n        assembly { id := chainid() }\n        return id;\n    } //end fun\n    \n    /**\n     * @dev status msg\n     * @param _text status text  \n     * @param _params he parameters \n     */\n    function statusMsg(string memory _text, string memory _params) public pure returns(string memory) {\n        return string(abi.encodePacked(\"XPIE:\", _text , \":\", _params));\n    }\n\n\n    /**\n     * @dev status msg\n     * @param _text status text  \n     * @param _params he parameters \n     */\n    function statusMsg(string memory _text, bytes32  _params) public pure returns(string memory) {\n        return statusMsg(_text,string(abi.encodePacked(_params)));\n    }\n\n\n    /**\n     * @dev status msg\n     * @param _text status text  \n     */\n    function statusMsg(string memory _text) public pure returns(string memory) {\n        return statusMsg(_text,string(abi.encodePacked(\"\")));\n    }\n\n \n    function toBytes32(uint256 _data) public pure returns(bytes32) {\n        return keccak256(abi.encodePacked(_data));\n    }\n\n    function toBytes32(string memory _data) public pure returns(bytes32) {\n        return keccak256(abi.encodePacked(_data));\n    }\n\n    function toBytes32(address _data) public pure returns(bytes32) {\n        return keccak256(abi.encodePacked(_data));\n    }\n\n}"
    },
    "contracts/Storage/DataStore.sol": {
      "content": "/*\n* LibertyPie Project (https://libertypie.com)\n* @author https://github.com/libertypie (hello@libertypie.com)\n* @license SPDX-License-Identifier: MIT\n*/\n\npragma solidity ^0.7.6;\n\nimport \"../PermissionManager/PM.sol\";\n//import \"./Storage.sol\";\nimport \"./Interfaces/IStorage.sol\";\n\ncontract DataStore is PM {\n  \n    event SetStorage(address indexed _contractAddress);\n\n    /**\n     * Store address\n     */\n     IStorage public STORAGE_CONTRACT;\n\n     bool dataStoreInitialized;\n\n    //initialize data store \n    function initializeDataStore(address _storageContract) internal {\n\n        require(!dataStoreInitialized, \"DATASTORE_ALREADY_INITIALIZED\");\n        require(_storageContract != address(0),\"XPIE:VALID_STORAGE_ADDRESS_REQUIRED\");\n\n        STORAGE_CONTRACT = IStorage(_storageContract);\n\n        emit SetStorage(_storageContract);\n\n        dataStoreInitialized = true;\n    } //end fun\n\n    /**\n    * @dev this returns an instance of he same contract\n    */\n    function getDataStore() public view returns(IStorage) {\n        return STORAGE_CONTRACT;\n    }\n\n    /**\n     * setStorage\n     */\n     function setStorage(address _storageContract) external onlySuperAdmin {\n        \n        require(_storageContract != address(0),\"XPIE:VALID_STORAGE_ADDRESS_REQUIRED\");\n        \n        STORAGE_CONTRACT = IStorage(_storageContract);\n\n        emit SetStorage(_storageContract);\n     }\n        \n}"
    },
    "contracts/Storage/Interfaces/IStorage.sol": {
      "content": "\n/*\n* LibertyPie Project (https://libertypie.com)\n* @author https://github.com/libertypie (hello@libertypie.com)\n* @license SPDX-License-Identifier: MIT\n*/\npragma solidity ^0.7.6;\npragma experimental ABIEncoderV2;\n\nimport \"./IPaymentMethodsStore.sol\";\nimport \"./IAssetStore.sol\";\nimport \"./IOfferStore.sol\";\nimport \"./IConfigStore.sol\";\n\ninterface IStorage is IPaymentMethodsStore, IAssetStore, IOfferStore, IConfigStore {\n    \n    /**\n     * Basic Store setters\n     */\n    function setUint256(bytes32 _key, uint256 _data) external;\n    function setInt256(bytes32 _key, int256 _data) external;\n    function setString(bytes32 _key, string calldata _data) external;\n    function setBool(bytes32 _key, bool _data) external;\n    function setAddress(bytes32 _key, address _data) external;\n    function setBytes(bytes32 _key, bytes memory _data) external;\n\n    /**\n     * Basic store getters\n     */\n    function getUint256(bytes32 _key) external view returns(uint256);\n    function getInt256(bytes32 _key) external view returns(int256);\n    function getBool(bytes32 _key) external view returns(bool);\n    function getAddress(bytes32 _key) external view returns(address);\n    function getString(bytes32 _key) external view returns(string memory);\n\n\n}"
    },
    "contracts/Storage/Interfaces/IPaymentMethodsStore.sol": {
      "content": "/*\n* LibertyPie Project (https://libertypie.com)\n* @author https://github.com/libertypie (hello@libertypie.com)\n* @license SPDX-License-Identifier: MIT\n*/\npragma solidity ^0.7.6;\npragma experimental ABIEncoderV2;\n\nimport \"../../Commons/PaymentMethodsStructs.sol\";\n\ninterface IPaymentMethodsStore {\n\n    function getNextPaymentMethodId() external returns(uint256);\n    function getNextPaymentMethodCategoryId() external returns(uint256);\n    function savePaymentMethodsCategoryData(uint256 _id, PaymentMethodsStructs.CategoryItem memory _data ) external;\n    function savePaymentMethodData(uint256 _id,PaymentMethodsStructs.PaymentMethodItem memory _data ) external;\n    function deletePaymentMethodsCategoryData(uint256 _id) external;\n    function deletePaymentMethodData(uint256 _id) external;\n    function getTotalPaymentMethodsCategories() external view  returns (uint256);\n    function getTotalPaymentMethods() external view  returns (uint256);\n    function getPaymentMethodsCategoryData(uint256 _id) external view returns (PaymentMethodsStructs.CategoryItem memory);\n    function getPaymentMethodData(uint256 _id) external view returns (PaymentMethodsStructs.PaymentMethodItem memory);\n\n}"
    },
    "contracts/Storage/Interfaces/IAssetStore.sol": {
      "content": "/*\n* LibertyPie Project (https://libertypie.com)\n* @author https://github.com/libertypie (hello@libertypie.com)\n* @license SPDX-License-Identifier: MIT\n*/\npragma solidity ^0.7.6;\npragma experimental ABIEncoderV2;\n\nimport \"../../Commons/AssetsStructs.sol\";\n\ninterface IAssetStore {\n\n    function getNextAssetId() external returns(uint256);\n    function getTotalAssets() external view returns (uint256);\n    function saveAssetData(uint256 _id,AssetsStructs.AssetItem memory _data) external; \n    function getAssetData(uint256 _id) external view returns(AssetsStructs.AssetItem memory);\n    function getAssetIdByAddress(address _address) external view returns (uint256);\n    function getAssetDataByAddress(address _address) external view returns (AssetsStructs.AssetItem memory);\n\n}"
    },
    "contracts/Storage/Interfaces/IOfferStore.sol": {
      "content": "/*\n* LibertyPie Project (https://libertypie.com)\n* @author https://github.com/libertypie (hello@libertypie.com)\n* @license SPDX-License-Identifier: MIT\n*/\npragma solidity ^0.7.6;\npragma experimental ABIEncoderV2;\n\nimport \"../../Commons/OffersStructs.sol\";\n\ninterface IOfferStore {\n\n    function getNextOfferId() external returns(uint256);\n    function getTotalOffers() external view  returns (uint256);\n    function saveOfferData(uint256  _id, OffersStructs.OfferItem memory _data) external;\n    function getOfferData(uint256 _id) external view returns(OffersStructs.OfferItem memory);\n    function deleteOfferData(uint256 _id) external;\n\n     function getOfferRating(uint256 offerId) external view returns (uint);\n    function setOfferRating(uint256 offerId, uint rating) external;\n\n    //indexes\n    function setOfferIndex(bytes32 _indexName, bytes32 _key, uint256 _id) external;\n}"
    },
    "contracts/Storage/Interfaces/IConfigStore.sol": {
      "content": "/*\n* LibertyPie Project (https://libertypie.com)\n* @author https://github.com/libertypie (hello@libertypie.com)\n* @license SPDX-License-Identifier: MIT\n*/\npragma solidity ^0.7.6;\npragma experimental ABIEncoderV2;\n\nimport \"../../Commons/ConfigsStructs.sol\";\n\n\ninterface IConfigStore {\n\n    function getConfigData(string memory _key) external view returns (bytes32);\n    function addConfigData(string memory _key, bytes32 _value) external;\n    function getAllConfigData() external view returns (ConfigsStructs.ConfigItem[] memory);\n\n}"
    },
    "contracts/Commons/PaymentMethodsStructs.sol": {
      "content": "/*\n* LibertyPie Project (https://libertypie.com)\n* @author https://github.com/libertypie (hello@libertypie.com)\n* @license SPDX-License-Identifier: MIT\n*/\npragma solidity ^0.7.6;\npragma experimental ABIEncoderV2;\n\n/**\n * @dev payment method struct Implementation\n */\ncontract PaymentMethodsStructs {\n    \n\n   struct PaymentMethodItem {\n      uint256 id; \n      string  name;\n      uint256 categoryId;\n      uint256 minPaymentWindow;\n      uint256 maxPaymentWindow;\n      string[] countries;\n      string[] continents;\n      bool isEnabled;\n   }\n\n\n   /**\n    * category Struct\n    */\n    struct CategoryItem {\n        uint256 id; \n        string name;\n        bool isEnabled;\n    }\n    \n}"
    },
    "contracts/Commons/OffersStructs.sol": {
      "content": "/*\n* LibertyPie Project (https://libertypie.com)\n* @author https://github.com/libertypie (hello@libertypie.com)\n* @license SPDX-License-Identifier: MIT\n*/\npragma solidity ^0.7.6;\npragma experimental ABIEncoderV2;\n\n/**\n * @dev offer struct Implementation\n */\ncontract OffersStructs {\n    \n    struct OfferInfo {\n        address asset;\n        bytes32 offerType;\n        bytes32 countryCode;\n        bytes32 currencyCode;\n        uint256  paymentMethod;\n        string  externalInfoHash;\n        int     externalStoreId;\n        bool    isEnabled;\n        uint256 expiry;\n    }\n\n    struct PricingInfo {\n        bytes32   pricingMode;\n        uint256   profitMargin;\n        uint256   fixedPrice;\n    }\n\n    struct TradeInfo {\n        uint256  minTradeAmountLimit;\n        uint256  maxTradeAmountLimit;\n        bool     hasSecurityDeposit;\n        uint256  securityDepositRate;\n        uint256  paymentWindow;\n        uint256  partnerMinimumTrades;\n        uint256  partnerMinimumReputation;\n    }\n    \n    struct OfferItem {\n        uint256      id;\n        address      owner;\n        OfferInfo    offerInfo;\n        PricingInfo  pricingInfo;\n        TradeInfo    tradeInfo;\n    }  \n\n\n\n    //offer index Item\n    //struct OfferIndexesItem {\n    //   mapping(bytes32 => uint256[]) ids;\n    //} \n\n}"
    },
    "contracts/PriceFeeds/Oracles/IPriceFeed.sol": {
      "content": "/*\n* LibertyPie Project (https://libertypie.com)\n* @author https://github.com/libertypie (hello@libertypie.com)\n* @license SPDX-License-Identifier: MIT\n*/\npragma solidity ^0.7.6;\npragma experimental ABIEncoderV2;\n\ninterface IPriceFeed {\n    //string public providerName;\n    function getLatestPrice(string memory _asset) external view returns(uint256);\n    function setAssetPriceFeedContract(string memory _asset, address _contract) external;\n}"
    },
    "contracts/PriceFeeds/Oracles/ChainLink.sol": {
      "content": "/*\n* LibertyPie Project (https://libertypie.com)\n* @author https://github.com/libertypie (hello@libertypie.com)\n* @license SPDX-License-Identifier: MIT\n*/\npragma solidity ^0.7.6;\npragma experimental ABIEncoderV2;\n\nimport \"./IPriceFeed.sol\";\nimport \"../../Base.sol\";\nimport \"@chainlink/contracts/src/v0.7/interfaces/AggregatorV3Interface.sol\";\n\n\ncontract ChainLink is IPriceFeed, Base {\n\n    string public providerName = \"ChainLink\";\n\n\n    //lets create storage for the contracts \n    //assetPair => contractAddress\n    mapping(string  => address) private feedsContracts;\n    \n    /**\n     * @dev set priceFeed contract\n     * @param _asset the asset  to fetch price feed\n     * @param _contract feed contract\n     */\n    function _setPriceFeedContract(string memory _asset, address _contract) private {\n        setAssetPriceFeedContract(_asset, _contract);\n    }\n\n    /**\n     * @dev set priceFeed contract\n     * @param _asset the asset  to fetch price feed\n     * @param _contract feed contract\n     */\n    function setAssetPriceFeedContract(string memory _asset, address _contract) public override onlyAdmin {\n        //lets get chain id \n        feedsContracts[_asset] = _contract;\n    } //end fun \n\n    /**\n     * getAggregatorV3Interface\n     */\n    function getPriceFeedContract(string memory _asset) public view returns(address) {\n        \n        //lets get chainId \n        address _contract = feedsContracts[_asset];\n\n        require(_contract != address(0), statusMsg(\"CHAIN_FEED_CONTRACT_MISSING\",_asset));\n\n        return _contract;\n    }\n\n    /**\n     * @dev get latest price\n     * @param _asset the asset which we need latest price for\n     */\n    function getLatestPrice(string memory _asset) public override  view returns(uint256) {\n        \n        AggregatorV3Interface priceFeed = AggregatorV3Interface(getPriceFeedContract(_asset));\n\n         (\n            uint80 roundID, \n            int price,\n            uint startedAt,\n            uint timeStamp,\n            uint80 answeredInRound\n        ) = priceFeed.latestRoundData();\n\n        return uint256(price);\n    } //end get price\n\n}//end contract"
    },
    "contracts/PriceFeeds/Oracles/OpenPriceFeed.sol": {
      "content": "/*\n* LibertyPie Project (https://libertypie.com)\n* @author https://github.com/libertypie (hello@libertypie.com)\n* @license SPDX-License-Identifier: MIT\n*/\npragma solidity ^0.7.6;\npragma experimental ABIEncoderV2;\n\nimport \"./IPriceFeed.sol\";\nimport \"../../Base.sol\";\n\ninterface UniswapAnchoredView {\n    function price(string calldata symbol) external view returns (uint);\n}\n\ncontract OpenPriceFeed is Base, IPriceFeed {\n\n    string public providerName = \"Open Price Feed\";\n\n     //if the uniswap anchor contract is changed\n    event uniswapAnchorContractChanged(address indexed _newAddress);\n\n    //uniswap anchored view contract\n    UniswapAnchoredView public  UNISWAP_ANCHORED_VIEW;\n\n    /**\n     * @dev initiate open price feed\n     */\n    function _initialize() private {\n        \n        uint256  chainId = getChainID();\n\n        address feedContractAddress;\n        \n\n        //mainnet , default mainnet's address is  hardcoded in OpenPriceFeed.sol\n        if(chainId  == 1){ feedContractAddress = 0x922018674c12a7F0D394ebEEf9B58F186CdE13c1;  } // if ethereum mainnet\n        else if(chainId == 3){ feedContractAddress = 0xBEf4E076A995c784be6094a432b9CA99b7431A3f; }  // if ropsten\n        else if(chainId == 42){  feedContractAddress = 0xbBdE93962Ca9fe39537eeA7380550ca6845F8db7; } //if kovan\n        else {\n            //revert(\"OpenPriceFeed: Unknown cahinId, kindly use  ropsten, kovan or mainnet\");\n        }\n\n        _setUniswapAnchorContract(feedContractAddress);\n    }\n\n\n    constructor() {\n        _initialize();\n    }\n\n    /**\n     * @dev update uniswap anchor contract\n     * @param _newAddress  the new contract address\n     */\n    function _setUniswapAnchorContract(address _newAddress) private  {\n        \n        UNISWAP_ANCHORED_VIEW = UniswapAnchoredView(_newAddress);\n\n        //emit event\n        emit uniswapAnchorContractChanged(_newAddress);\n\n    } //end  fun\n\n\n    /**\n     * @dev update uniswap anchor contract\n     * @param _newAddress  the new contract address\n     */\n    function setUniswapAnchorContract(address _newAddress) external onlyAdmin ()  {\n        _setUniswapAnchorContract(_newAddress);\n    }\n\n    /**\n     * getLatestPrice\n     */\n    function getLatestPrice(string memory _symbol) public override view returns (uint256) {\n        return UNISWAP_ANCHORED_VIEW.price(_symbol);\n    } //end fun\n\n\n    /**\n     * @dev set priceFeed contract\n     * @param _asset the asset  to fetch price feed\n     * @param _contract feed contract\n     */\n    function setAssetPriceFeedContract(string memory _asset, address _contract) public override onlyAdmin {}\n\n}//end "
    },
    "@chainlink/contracts/src/v0.7/interfaces/AggregatorV3Interface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.7.0;\n\ninterface AggregatorV3Interface {\n\n  function decimals() external view returns (uint8);\n  function description() external view returns (string memory);\n  function version() external view returns (uint256);\n\n  // getRoundData and latestRoundData should both raise \"No data present\"\n  // if they do not have data to report, instead of returning unset values\n  // which could be misinterpreted as actual reported values.\n  function getRoundData(uint80 _roundId)\n    external\n    view\n    returns (\n      uint80 roundId,\n      int256 answer,\n      uint256 startedAt,\n      uint256 updatedAt,\n      uint80 answeredInRound\n    );\n  function latestRoundData()\n    external\n    view\n    returns (\n      uint80 roundId,\n      int256 answer,\n      uint256 startedAt,\n      uint256 updatedAt,\n      uint80 answeredInRound\n    );\n\n}\n"
    },
    "contracts/Offers.sol": {
      "content": "/*\n* LibertyPie Project (https://libertypie.com)\n* @author https://github.com/libertypie (hello@libertypie.com)\n* @license SPDX-License-Identifier: MIT\n*/\n\npragma solidity ^0.7.6;\npragma experimental ABIEncoderV2;\n\n\nimport \"./Assets.sol\";\nimport \"./Commons/OffersStructs.sol\";\nimport \"./Commons/PaymentMethodsStructs.sol\";\nimport \"./Base.sol\";\n\ncontract Offers is Base {\n\n    /*\n     * @dev add a new offer  event \n     */\n    event NewOffer(uint256 offerId);\n    \n    event DisableOffer(uint256 offerId);\n\n    event UpdateOffer(uint256 offerId);\n\n   struct OfferListFilter {\n      address  asset;\n      bytes32  offerType;\n      bytes32  pricingMode;\n      bytes32  countryCode;\n      address  owner;\n      uint256  paymentMethod;\n      uint256  minRating;\n   }\n\n   int public OFFER_SORT_ASC =  0;\n   int public  OFFER_SORT_DESC = 1;\n\n   struct OfferSort {\n      bytes32 orderBy;\n      int     orderMode;\n   }\n    \n    // offer types\n    bytes32 OFFER_TYPE_BUY  =  toBytes32(\"buy\");\n    bytes32 OFFER_TYPE_SELL =  toBytes32(\"sell\");\n\n    bytes32 PRICING_MODE_MARKET = toBytes32(\"market\");\n    bytes32 PRICING_MODE_FIXED = toBytes32(\"fixed\");\n\n    Assets  _assets = Assets(address(this)); \n\n   bytes32 OFFERS_BY_USER_ADDRESS_INDEX_GROUP   = toBytes32(\"OFFERS_BY_USER_ADDRESS\");\n\n   bytes32 OFFERS_BY_ASSET_INDEX_GROUP          = toBytes32(\"OFFERS_BY_ASSET\");\n\n   bytes32 OFFERS_BY_COUNTRY_INDEX_GROUP        = toBytes32(\"OFFERS_BY_COUNTRY\");\n\n   bytes32 OFFERS_BY_CURRENCY_INDEX_GROUP       = toBytes32(\"OFFERS_BY_CURRENCY\");\n\n   bytes32 OFFERS_BY_OFFER_TYPE_INDEX_GROUP     = toBytes32(\"OFFERS_BY_OFFER_TYPE\");\n\n   bytes32 OFFERS_BY_PAYMENT_METHOD_INDEX_GROUP = toBytes32(\"OFFERS_BY_PAYMENT_METHOD\");\n\n   //offer rating groups\n   bytes32 OFFERS_RATING_GROUPS =  toBytes32(\"OFFERS_RATING_GROUPS\");\n        \n   /**\n   * @dev add a  new offer \n   *\n   * @dev  OffersStructs.OfferInfo memory offerInfo \n      * @dev  asset the contract  address of the  asset  you wish to add the ad\n      * @dev  offerType the offer type, either buy or sell\n      * @dev  countryCode the country  where   ad is   targeted at\n      * @dev  currencyCode 2 letter iso currency code \n      * @dev  paymentMethod enabled payment type for the offer\n      * @dev  extraDataHash  extra data hash\n      * @dev  extraDataStoreId Store , 1 for ipfs, 2 for sia skynet , 3....\n      * @dev  isEnabled, if offer is enabled or not\n      * @dev  expiry  offer expiry, 0 for non expiring offer, > 0 for expiring offer\n\n   * @dev OffersStructs.PricingInfo memory pricingInfo\n      * @dev  pricingMode the pricing mode for the offer\n      * @dev  profitMargin if the pricingMode is market, then the amount in percentage added to the market price\n      * @dev  fixedPrice if pricingMode is fixed, then the offer amount in usd\n\n   * @dev OffersStructs.TradeInfo memory offerTradeInfo\n      * @dev  minTradeAmountLimit uint256 minimum trade amount limit for the offer\n      * @dev  maxTradeAmountLimit uint256 maximum trade  amount limit for the offer\n      * @dev  hasSecurityDeposit bool if security deposit is enabled\n      * @dev  securityDepositRate uint256 if security deposit is enabled, the amount in percentage\n      * @dev  paymentWindow uint256 the time duration in milliseconds required to make a payment after a trade is opened\n      * @dev  partnerMinimumTrades uint256 partner minimum required trades to be qualified to open trade to this offer\n      * @dev  partnerMinimumReputation uint256 partner minimum reputation required to qualify for this offer\n   */\n   function newOffer(\n      OffersStructs.OfferInfo memory _offerInfo,\n      OffersStructs.PricingInfo memory _pricingInfo,\n      OffersStructs.TradeInfo memory _offerTradeInfo\n   ) external {\n      \n\n      //validate country\n      require(_offerInfo.countryCode.length == 2, \"XPIE:INVALID_COUNTRY_CODE\");\n\n      require(_offerInfo.currencyCode.length == 2, \"XPIE:INVALID_CURRENCY_CODE\");\n\n      //check if asset is supported\n      require(_assets.isAssetSupported(_offerInfo.asset),\"XPIE:UNSUPPORTED_ASSET\");\n   \n      require((_offerInfo.offerType == OFFER_TYPE_BUY || _offerInfo.offerType == OFFER_TYPE_SELL), \"XPIE:INVALID_OFFER_TYPE\");\n\n      //save offer data \n      //lets get nextOfferId\n      uint256 offerId = getDataStore().getNextOfferId();\n\n      PaymentMethodsStructs.PaymentMethodItem memory paymentMethodData =  getDataStore().getPaymentMethodData(\n         _offerInfo.paymentMethod\n      );\n\n      //validate payment method\n      require(paymentMethodData.isEnabled == true, \"XPIE:UNKNOWN_PAYMENT_METHOD\");\n\n      //validate the pricing mode\n      require((_pricingInfo.pricingMode == PRICING_MODE_MARKET || _pricingInfo.pricingMode == PRICING_MODE_FIXED), \"XPIE:UNKOWN_PRICING_MODE\");\n\n      //i security deposit is enabled, lets process it\n      if(_offerTradeInfo.hasSecurityDeposit == true){\n         \n         require(_offerTradeInfo.securityDepositRate > 0, statusMsg(\"SECURITY_DEPOSIT_TOO_SMALL\", toBytes32(0)));\n\n          //min payment window\n         bytes32 maxSecurityDeposit = getConfig(\"MAX_SECURITY_DEPOSIT\");\n\n         require(toBytes32(_offerTradeInfo.securityDepositRate) > maxSecurityDeposit, statusMsg(\"SECURITY_DEPOSIT_TOO_LARGE\",maxSecurityDeposit));\n\n      } //end if security deposit is enabled\n\n      //min payment window\n      bytes32 minPaymentWindow = getConfig(\"MIN_PAYMENT_WINDOW\");\n\n      //compare \n      require(toBytes32(_offerTradeInfo.paymentWindow) >= minPaymentWindow, statusMsg(\"PAYMENT_WINDOW_TOO_SMALL\", minPaymentWindow));\n\n      //if we have partner min reputation\n      if(_offerTradeInfo.partnerMinimumReputation > 0){\n\n         //lets check reputation\n         bytes32 maxReputation = getConfig(\"MAX_REPUTATION\");\n\n         require(toBytes32(_offerTradeInfo.partnerMinimumReputation) <= maxReputation, statusMsg(\"PARTNER_REPUTATION_EXCEEDS_MAX\", maxReputation));\n      } //end if\n\n      //lets now prepare for save \n      getDataStore().saveOfferData(\n         offerId,\n         OffersStructs.OfferItem({\n            id:          offerId,\n            owner:       msg.sender,\n            offerInfo:   _offerInfo,\n            pricingInfo: _pricingInfo,\n            tradeInfo:   _offerTradeInfo\n         })\n      );\n\n\n      //lets now save indexes \n\n      //add offer index for user address \n      getDataStore().setOfferIndex(OFFERS_BY_USER_ADDRESS_INDEX_GROUP, toBytes32(msg.sender), offerId);\n\n      //add offer index for asset group\n      getDataStore().setOfferIndex(OFFERS_BY_ASSET_INDEX_GROUP, toBytes32(_offerInfo.asset), offerId);\n\n       //add offer index for country group\n      getDataStore().setOfferIndex(OFFERS_BY_COUNTRY_INDEX_GROUP, _offerInfo.countryCode, offerId);\n\n       //add offer index for currency group\n      getDataStore().setOfferIndex(OFFERS_BY_CURRENCY_INDEX_GROUP, _offerInfo.currencyCode, offerId);\n\n      //add offer index for payment method group\n      getDataStore().setOfferIndex(OFFERS_BY_PAYMENT_METHOD_INDEX_GROUP, toBytes32(_offerInfo.paymentMethod), offerId);\n\n\n      getDataStore().setOfferIndex(OFFERS_BY_OFFER_TYPE_INDEX_GROUP, _offerInfo.offerType, offerId);\n      \n      emit NewOffer(offerId);\n   } //end fun \n\n\n   /**\n    * @dev get offer by id \n    * @param _id offer id\n    */\n   function getOfferById(uint256 _id) public view returns (OffersStructs.OfferItem memory) {\n      return getDataStore().getOfferData(_id);\n   }\n\n\n   /**\n    * @dev get list of offers with filter included \n    * @dev Offer filter\n    */\n   function getOffers(\n      uint256 startOfferId,\n      uint256 dataPerPage,\n      OfferSort memory sort,\n      OfferListFilter memory _filter\n   ) public view returns (OffersStructs.OfferItem[] memory) {\n\n      require(dataPerPage > 0 && dataPerPage <= 100, statusMsg(\"DATA_PER_PAGE_PARAM_INVALID\", toBytes32(dataPerPage)));\n\n      if(sort.orderBy == \"id\" && sort.orderMode == OFFER_SORT_ASC){\n        return  getOffersSortByIdsASC(startOfferId, dataPerPage, _filter);\n      } \n\n      /*\n      else if(sort.orderBy == \"id\" && sort.orderMode == OFFER_SORT_DESC) {\n         return getOffersSortByIdsASC(startId, dataPerPage, _filter);\n      }*/\n\n      return getOffersSortByIdsDESC(startOfferId, dataPerPage, _filter);\n\n    } //end fun \n\n\n    /**\n     * getOffersSortByIdsDesc\n     */\n     function getOffersSortByIdsDESC(\n         uint256 startOfferId,\n         uint256 dataPerPage,\n         OfferListFilter memory _filter\n     ) private view returns (OffersStructs.OfferItem[] memory) {\n\n         uint256 totalOffers = getDataStore().getTotalOffers();\n\n         OffersStructs.OfferItem[] memory processedData = new OffersStructs.OfferItem[] (dataPerPage + 1);\n\n         if(startOfferId == 0) {\n            startOfferId = totalOffers;\n         }\n\n         for(uint256 i = startOfferId; i <= 0; i--){\n            \n            OffersStructs.OfferItem memory offerItem  = getOfferById(i);\n            \n            if(!computeOfferListFilter(offerItem, _filter)) {\n               continue;\n            }\n\n            //add offer item into the array\n            processedData[i] = offerItem;\n\n            if(processedData.length >= dataPerPage){\n               break;\n            }\n         } //end loop\n\n         return processedData;\n     } //end fun\n\n\n     /**\n     * getOffersSortByIdsASC\n     */\n     function getOffersSortByIdsASC(\n         uint256 startOfferId,\n         uint256 dataPerPage,\n         OfferListFilter memory _filter\n     ) private view returns (OffersStructs.OfferItem[] memory) {\n\n         uint256 totalOffers = getDataStore().getTotalOffers();\n\n         OffersStructs.OfferItem[] memory processedData = new OffersStructs.OfferItem[] (dataPerPage + 1);\n\n\n         for(uint256 i = startOfferId; i <= totalOffers; i++){\n            \n            OffersStructs.OfferItem memory offerItem  = getOfferById(i);\n            \n            if(!computeOfferListFilter(offerItem, _filter)) {\n               continue;\n            }\n\n            //add offer item into the array\n            processedData[i] = offerItem;\n\n            if(processedData.length >= dataPerPage){\n               break;\n            }\n         } //end loop\n\n         return processedData;\n     } //end fun\n\n     /**\n      * computeOfferListFilter\n      */\n      function computeOfferListFilter(\n         OffersStructs.OfferItem memory offerItem,\n         OfferListFilter memory _filter\n      ) public view returns(bool) {\n\n         bool isEligible = true;\n\n         //lets check filters \n         if(_filter.owner != address(0) && !(_filter.owner == offerItem.owner)){\n            isEligible = false;\n         }\n\n         if(_filter.offerType.length > 0 && !(_filter.offerType == offerItem.offerInfo.offerType)){\n            isEligible = false;\n         }\n\n         if(_filter.pricingMode.length > 0 && !(_filter.pricingMode == offerItem.pricingInfo.pricingMode)){\n            isEligible = false;\n         }\n\n         if(_filter.countryCode.length > 0 && !(_filter.countryCode == offerItem.offerInfo.countryCode)) {\n            isEligible = false;\n         } //end if \n\n         //lets check offer rating\n         uint offerRating = getDataStore().getOfferRating(offerItem.id);\n\n         if(_filter.minRating > 0 && !(offerRating >= _filter.minRating)){\n            isEligible = false;\n         }\n\n\n         return isEligible;\n      } //end \n\n}  //end contract "
    },
    "contracts/PaymentMethods.sol": {
      "content": "/*\n* LibertyPie Project (https://libertypie.com)\n* @author https://github.com/libertypie (hello@libertypie.com)\n* @license SPDX-License-Identifier: MIT\n*/\n\npragma solidity ^0.7.6;\npragma experimental ABIEncoderV2;\n\n//import \"./PermissionManager/PM.sol\";\n\n//import \"./Storage/StoreProxy.sol\";\nimport \"./Commons/PaymentMethodsStructs.sol\";\nimport \"./Base.sol\";\n\ncontract PaymentMethods is Base {\n\n    event AddPaymentMethodCategory(uint256 _id);\n    event RemovePaymentMethodCategory(uint256 _id);\n    event UpdatePaymentMethodCategory(uint256 categoryId);\n    event AddPaymentMethod(uint256 _id);\n    event UpdatePaymentMethod(uint256 _id);\n    event RemovePaymentMethod(uint256 _id);\n\n        /**\n     * @dev getTotalPaymentMethods\n     */\n     function getTotalPaymentMethods() public view returns(uint256) {\n         return getDataStore().getTotalPaymentMethods();\n     } //end fun \n\n    /**\n     * @dev getTotalPaymentMethods\n     */\n     function getTotalPaymentMethodsCategories() public view returns(uint256) {\n         return getDataStore().getTotalPaymentMethodsCategories();\n     } //end fun \n\n\n    /**\n    * @dev add a new payment type category\n    * @param name category name in string\n    * @return uint256 new category  id\n   */\n   function addPaymentMethodCategory(\n       string   memory name,\n       bool isEnabled\n    ) external  onlyAdmin() returns(uint256) {\n     \n        uint256 catId = getDataStore().getNextPaymentMethodCategoryId();\n\n        PaymentMethodsStructs.CategoryItem memory _dataToSave = PaymentMethodsStructs.CategoryItem(\n            catId,\n            name,\n            isEnabled\n        );\n\n        getDataStore().savePaymentMethodsCategoryData(\n            catId,\n            _dataToSave\n        );\n\n        emit AddPaymentMethodCategory(catId);\n\n        return catId;\n    } //end fun \n\n\n    /**\n    * @dev delete a cetegory\n    * @param _id category  id\n    */\n    function removePaymentMethodCategory(uint256 _id) external onlyAdmin() {\n        getDataStore().deletePaymentMethodsCategoryData(_id);\n        emit RemovePaymentMethodCategory(_id);\n    } //end fun \n\n\n    /**\n    * @dev add a new payment type category\n    * @param categoryId the category id\n    * @param newCategoryName  new category name to change\n    * @param isEnabled if the category is enabled or not\n    */\n    function updatePaymentMethodCategory(\n        uint256 categoryId,  \n        string memory newCategoryName,\n        bool isEnabled\n    ) external  onlyAdmin() {\n      \n       PaymentMethodsStructs.CategoryItem memory _dataToSave = PaymentMethodsStructs.CategoryItem(\n            categoryId,\n            newCategoryName,\n            isEnabled\n        );\n\n        getDataStore().savePaymentMethodsCategoryData(\n            categoryId,\n            _dataToSave\n        );\n\n        emit UpdatePaymentMethodCategory(categoryId);\n    } //end fun \n\n\n    /**\n    * @dev add a new payment method\n    * @param name payment method name\n    * @param categoryId category id for the new payment  type\n    * @param countries supported countries\n    * @param continents Supported continents\n    * @param isEnabled is this payment method enabled\n    * @return uint256\n   */\n   function addPaymentMethod(\n       string memory name, \n       uint256 categoryId,\n       uint256 minPaymentWindow,\n       uint256 maxPaymentWindow,\n       string[] memory countries,\n       string[] memory continents,\n       bool isEnabled \n    ) public  onlyAdmin() returns(uint256) {\n\n        //lets  check if categoryId exists \n        require(categoryId > 0 && categoryId <= getTotalPaymentMethodsCategories(),statusMsg(\"UNKNOWN_CATEGORY\",toBytes32(categoryId)));\n        require(bytes(name).length > 0, statusMsg(\"PAYMENT_METHOD_NAME_REQUIRED\"));\n\n        //avoid totalPaymentTypes++\n        //counting starts from 1, so index 0 wont exist\n        uint256 id = getDataStore().getNextPaymentMethodId();\n\n        PaymentMethodsStructs.PaymentMethodItem memory _dataToSave = PaymentMethodsStructs.PaymentMethodItem(\n            id, \n            name, \n            categoryId,\n            minPaymentWindow,\n            maxPaymentWindow,\n            countries,\n            continents,\n            isEnabled\n        );\n\n        getDataStore().savePaymentMethodData(\n            id,\n            _dataToSave\n        );\n\n        emit AddPaymentMethod(id);\n\n        return id;\n   } //end \n\n\n    /**\n    * @dev getPaymentMethod\n    * @param _id paymentMethod id\n    */\n    function getPaymentMethod(uint256 _id) public view returns (PaymentMethodsStructs.PaymentMethodItem memory) {\n        return getDataStore().getPaymentMethodData(_id);\n    }\n\n   /**\n   * @dev remove  a payment method \n   * @param _id  the payment method id\n   */\n   function removePaymentMethod(uint256 _id) external  onlyAdmin() { \n      getDataStore().deletePaymentMethodData(_id); \n      emit RemovePaymentMethod(_id);\n   }\n\n\n   /**\n   *  @dev update  payment type info\n   *  @param _dataToSave payment method data\n   *  @param  categoryId the new category id of the payment type\n   */\n   function updatePaymentMethod(\n       PaymentMethodsStructs.PaymentMethodItem memory _dataToSave,\n       uint256 categoryId\n    ) external  onlyAdmin()  {\n        \n        //lets check if \n        require(_dataToSave.id > 0 && _dataToSave.id  <= getTotalPaymentMethods(),statusMsg(\"UNKNOWN_PAYMENT_METHOD\",toBytes32(_dataToSave.id)));\n\n         require(categoryId > 0 && categoryId <= getTotalPaymentMethodsCategories(),statusMsg(\"UNKNOWN_CATEGORY\",toBytes32(categoryId)));\n\n\n        getDataStore().savePaymentMethodData(\n            _dataToSave.id,\n            _dataToSave\n        );\n\n        emit UpdatePaymentMethod(_dataToSave.id);\n   } //end fun\n\n   /**\n   *  @dev get all payment types categories \n   *  @return  (PaymentMethodsStructs.CategoryItem[] memory) CategoryNames Array with category id as array index\n   */\n   function  getPaymentMethodsCategories() public view returns (PaymentMethodsStructs.CategoryItem[] memory) {\n    \n      uint256 totalCategories = getTotalPaymentMethodsCategories(); \n      PaymentMethodsStructs.CategoryItem[] memory  categoriesArray = new PaymentMethodsStructs.CategoryItem[] (totalCategories + 1);\n      \n      //mapping index starts with 1, not  0\n      for(uint256 i = 1; i <= totalCategories; i++ ){\n        categoriesArray[i] = getDataStore().getPaymentMethodsCategoryData(i);\n      }\n\n      return categoriesArray;\n   } //end fun \n\n   \n    /* \n   * @dev get payment types using it category id\n   * @param categoryId uint256 category id \n   * @return PaymentMethodsStructs.PaymentMethodItem[] memory\n   */\n   function getPaymentMethodsByCategory(uint256 categoryId) external view returns( PaymentMethodsStructs.PaymentMethodItem[] memory ) {\n\n      uint256 totalPaymentMethods = getTotalPaymentMethods();\n\n      //lets fetch the  payment types ids\n      PaymentMethodsStructs.PaymentMethodItem[] memory paymentMethodsArray   = new PaymentMethodsStructs.PaymentMethodItem[] (totalPaymentMethods + 1);\n\n        for(uint256  i = 1; i <= totalPaymentMethods; i++){\n\n            PaymentMethodsStructs.PaymentMethodItem memory paymentMethodData =  getPaymentMethod(i);\n\n            if(paymentMethodData.categoryId == categoryId && bytes(paymentMethodData.name).length > 0){\n                paymentMethodsArray[i] = paymentMethodData;\n            }\n        }\n\n        return paymentMethodsArray;\n   }  //end fun\n\n\n   /**\n   * @dev get all payment types \n   */\n   function getPaymentMethods() public view returns( PaymentMethodsStructs.PaymentMethodItem[] memory ) {\n\n      uint256 totalPaymentMethods = getTotalPaymentMethods();\n\n\n      PaymentMethodsStructs.PaymentMethodItem[] memory paymentMethodsArray   = new PaymentMethodsStructs.PaymentMethodItem[] (totalPaymentMethods + 1);\n\n      for(uint256 i = 1; i <= totalPaymentMethods; i++ ){\n         paymentMethodsArray[i] = getPaymentMethod(i);\n      }\n\n      return paymentMethodsArray;\n   }\n\n\n    /**\n    * @dev Fetch payment types and categories in a single query\n    */\n   function getPaymentMethodsAndCategories() \n        external \n        view \n        returns (PaymentMethodsStructs.CategoryItem[] memory,  PaymentMethodsStructs.PaymentMethodItem[] memory) \n    {\n      return (getPaymentMethodsCategories(),getPaymentMethods());\n   }//end \n    \n}//end contract"
    },
    "contracts/Storage/PaymentMethodsStore.sol": {
      "content": "/*\n* LibertyPie Project (https://libertypie.com)\n* @author https://github.com/libertypie (hello@libertypie.com)\n* @license SPDX-License-Identifier: MIT\n*/\npragma solidity ^0.7.6;\npragma experimental ABIEncoderV2;\nimport \"./StoreEditor.sol\";\nimport \"../Commons/PaymentMethodsStructs.sol\";\n\n\ncontract PaymentMethodsStore is StoreEditor  {\n\n    uint256  totalPaymentMethodsCategories;\n    uint256  totalPaymentMethods;\n\n    //paymentTypes categories\n    // format mapping(index => name)\n    // NOTE  That the index always starts with 1 and not 0\n    mapping(uint256 => PaymentMethodsStructs.CategoryItem) private  PaymentMethodsCategories;\n\n\n    // paymentTypes \n    // format mapping(index => name)\n    // NOTE  That the index always starts with 1 and not 0\n    mapping(uint256 => PaymentMethodsStructs.PaymentMethodItem) private PaymentMethodsData;\n\n\n     /**\n     * @dev generate or get next catId\n     */\n    function getNextPaymentMethodCategoryId() external onlyStoreEditor returns(uint256) {\n        return (++totalPaymentMethodsCategories);\n    }\n\n    /**\n     * @dev get total payment methods\n     */\n     function getTotalPaymentMethods() public view  returns (uint256) {\n        return totalPaymentMethods;\n     }\n\n       /**\n     * @dev get total categories\n     */\n     function getTotalPaymentMethodsCategories() public view  returns (uint256) {\n        return totalPaymentMethodsCategories;\n     }\n\n    /**\n     * getNextPaymentMethodId\n     */\n    function getNextPaymentMethodId() external onlyStoreEditor returns(uint256) {\n        return (++totalPaymentMethods);\n    }\n\n    /**\n     * addPaymentMethod\n     */\n    function savePaymentMethodData(uint256 _id,PaymentMethodsStructs.PaymentMethodItem memory _data ) external onlyStoreEditor {\n        PaymentMethodsData[_id] = _data;\n    }\n\n\n    /**\n     * @dev save category data\n     * @param _id category id\n     */\n    function savePaymentMethodsCategoryData(uint256 _id, PaymentMethodsStructs.CategoryItem memory _data ) external onlyStoreEditor { \n        PaymentMethodsCategories[_id] = _data;\n    }\n\n    /**\n     * deleteCategoryData\n     * @param _id category id\n     */\n    function deletePaymentMethodsCategoryData(uint256 _id) external  onlyStoreEditor {\n        delete PaymentMethodsCategories[_id];\n    }\n\n    /**\n     * deleteCategoryData\n     * @param _id category id\n     */\n    function deletePaymentMethodData(uint256 _id) external  onlyStoreEditor {\n        delete PaymentMethodsData[_id];\n    }\n    \n\n    /**\n     * get payment method category\n     * @param _id payment method category id\n     */\n     function getPaymentMethodsCategoryData(uint256 _id) external view returns (PaymentMethodsStructs.CategoryItem memory) {\n        return PaymentMethodsCategories[_id];\n     } //end fun \n\n    /**\n     * @dev get payment method data\n     * @param _id payment method id\n     */\n     function getPaymentMethodData(uint256 _id) external view returns (PaymentMethodsStructs.PaymentMethodItem memory) {\n        return PaymentMethodsData[_id];\n     } //end fun \n}"
    },
    "contracts/Storage/StoreEditor.sol": {
      "content": "\n/*\n* LibertyPie Project (https://libertypie.com)\n* @author https://github.com/libertypie (hello@libertypie.com)\n* @license SPDX-License-Identifier: MIT\n*/\npragma solidity ^0.7.6;\npragma experimental ABIEncoderV2;\n\ninterface IPERMISSION_MANAGER {\n    function hasRole(string memory roleName, address _address) external view returns(bool);\n}\n\ncontract StoreEditor {\n\n    bool isStoreEditorInitialized;\n    \n    IPERMISSION_MANAGER _permissionManager; \n\n    string STORAGE_EDITOR_ROLE = \"STORAGE_EDITOR\";\n\n\n    function setPermissionManager(address _contractAddress) internal {\n\n        require(!isStoreEditorInitialized,\"XPIE:STORE_EDITOR_ALREADY_INITIALIZED\");\n\n        _permissionManager = IPERMISSION_MANAGER(_contractAddress);\n\n        isStoreEditorInitialized = true;\n    }\n\n     //permissions \n    modifier onlyStoreEditor() {\n        \n        address _caller;\n        assembly { _caller := caller() }\n\n       //note, this must be the calling's contract address  PERMISSION_MANAGER.isStorageEditor(_getCaller())\n       require(_permissionManager.hasRole(STORAGE_EDITOR_ROLE,_caller),\"ONLY_STORAGE_EDITOR_ALLOWED\");\n       _;\n    }\n    \n}"
    },
    "contracts/Storage/Storage.sol": {
      "content": "/*\n* LibertyPie Project (https://libertypie.com)\n* @author https://github.com/libertypie (hello@libertypie.com)\n* @license SPDX-License-Identifier: MIT\n*/\npragma solidity ^0.7.6;\npragma experimental ABIEncoderV2;\n\nimport \"./BasicStore.sol\";\nimport \"./OffersStore.sol\";\nimport \"./StoreEditor.sol\";\nimport \"./PaymentMethodsStore.sol\";\nimport \"./AssetsStore.sol\";\nimport \"./ConfigStore.sol\";\n\ncontract Storage is\n        StoreEditor, \n        BasicStore, \n        OffersStore, \n        PaymentMethodsStore,\n        AssetsStore,\n        ConfigStore\n{\n    \n    /**\n     * @param _permissionManager accept permission manager contract address\n     */\n    constructor(address _permissionManager) {\n        setPermissionManager(_permissionManager);\n    }\n\n}   "
    },
    "contracts/Storage/BasicStore.sol": {
      "content": "\n/*\n* LibertyPie Project (https://libertypie.com)\n* @author https://github.com/libertypie (hello@libertypie.com)\n* @license SPDX-License-Identifier: MIT\n*/\npragma solidity ^0.7.6;\npragma experimental ABIEncoderV2;\nimport \"./StoreEditor.sol\";\n\ncontract BasicStore is StoreEditor {\n\n    /**\n     * @dev scalar values\n     */\n\n    //uint256 store \n    mapping(bytes32 => uint256) private uint256Store;\n\n    //int store \n    mapping(bytes32 => int256) private int256Store;\n     \n    //string store \n    mapping(bytes32 => string) private stringStore;\n\n    //bool store\n    mapping(bytes32 => bool) private boolStore;\n\n    //address store\n    mapping(bytes32 => address) private addressStore;\n\n    //bytes store\n    mapping(bytes32 => bytes) private bytesStore;\n\n     //mapping store\n    // key => mapping\n    mapping(bytes32 => mapping(bytes32 => bytes)) private mappingStore;\n\n    // nested mapping store \n    mapping(bytes32 => mapping(bytes32 => mapping(bytes32 => bytes))) private nestedMappingStore;\n\n    /**\n     * Setters\n     */\n\n    /**\n     * @dev set uint256  \n     */\n     function setUint256(bytes32 _key, uint256 _data) external  onlyStoreEditor {\n        uint256Store[_key] = _data;\n     }\n\n    /**\n     * @dev increment uint256 this adds a +1 to the exiting data\n     */\n     function incrementUint256(bytes32 _key) external  onlyStoreEditor returns(uint256) {\n        uint256Store[_key] += 1;\n     }\n\n    /**\n     * @dev set int256  \n     */\n     function setInt256(bytes32 _key, int256 _data) external  onlyStoreEditor {\n        int256Store[_key] = _data;\n     }\n\n    /**\n     * @dev set string  \n     */\n     function setString(bytes32 _key, string calldata _data) external onlyStoreEditor {\n        stringStore[_key] = _data;\n     }\n\n    /**\n     * @dev set boolean  \n     */\n     function setBool(bytes32 _key, bool _data) external onlyStoreEditor {\n        boolStore[_key] = _data;\n     }\n\n    /**\n     * @dev set address  \n     */\n     function setAddress(bytes32 _key, address _data) external onlyStoreEditor {\n        addressStore[_key] = _data;\n    }\n\n    /**\n     * @dev set bytes data  \n     */\n     function setBytes(bytes32 _key, bytes memory _data) external onlyStoreEditor {\n        bytesStore[_key] = _data;\n    }\n\n    /**\n     * Getters \n     */\n\n    /**\n     * get uint256\n     */\n    function getUint256(bytes32 _key) public view returns(uint256) {\n        return uint256Store[_key];\n    }\n\n    /**\n     * get int256\n     */\n    function getInt256(bytes32 _key) public view returns(int256) {\n        return int256Store[_key];\n    }\n\n    /**\n     * get bool\n     */\n    function getBool(bytes32 _key) public view returns(bool) {\n        return boolStore[_key];\n    }\n\n     /**\n     * get address\n     */\n    function getAddress(bytes32 _key) public view returns(address) {\n        return addressStore[_key];\n    }\n\n    /**\n     * get string\n     */\n    function getString(bytes32 _key) public view returns(string memory) {\n        return stringStore[_key];\n    }\n}"
    },
    "contracts/Storage/OffersStore.sol": {
      "content": "/*\n* LibertyPie Project (https://libertypie.com)\n* @author https://github.com/libertypie (hello@libertypie.com)\n* @license SPDX-License-Identifier: MIT\n*/\npragma solidity ^0.7.6;\npragma experimental ABIEncoderV2;\nimport \"./StoreEditor.sol\";\nimport \"../Commons/OffersStructs.sol\";\n\n\ncontract OffersStore is StoreEditor  {\n\n    //format is mapping(index => OffersStruct)\n    mapping(uint256 =>  OffersStructs.OfferItem) private OffersData;\n\n    \n    //OfferIndexes \n    mapping(bytes32 => mapping(bytes32 => uint256[])) private OffersIndexes;\n\n    //OfferStats \n    mapping(uint256 => uint) private OfferRatings;\n\n    //mapping(uint256 => uint256) private OfferRanking;\n\n    /**\n     * @dev totalOffers\n     */\n    uint256 private totalOffers;\n\n    /**\n     * @dev generate or get next offerId\n     */\n     function getNextOfferId() external onlyStoreEditor returns(uint256) {\n        return (++totalOffers);\n     }\n\n    /**\n     * getTotalOffers\n     */\n    function getTotalOffers() external view  returns (uint256){\n        return totalOffers;\n    }\n\n    /**\n     * @dev save offer data\n     * @param _id the offer id\n     * @param _data the offer data\n     */\n    function saveOfferData(uint256  _id, OffersStructs.OfferItem memory _data) external onlyStoreEditor {\n      OffersData[_id] = _data;\n    } //end fun\n\n\n    /**\n     * get offer by id\n     * @param _id offer id \n     * @return OffersStructs.OfferItem\n     */\n     function getOfferData(uint256 _id) external view returns(OffersStructs.OfferItem memory) {\n        return OffersData[_id];\n     } //end fun\n\n    /**\n     * delete offer data\n     * @param _id offer id \n     */\n     function deleteOfferData(uint256 _id) external onlyStoreEditor {\n         delete  OffersData[_id];\n     } //end \n\n    /**\n    * @dev setOfferIndex\n    * @param _indexName eg. toBytes32('OFFERS_BY_COUNTRY');\n    * @param _key eg. us (country code)\n    * @param _id the offer Id \n    */\n    function setOfferIndex(bytes32 _indexName, bytes32 _key, uint256 _id) external onlyStoreEditor {\n        OffersIndexes[_indexName][_key].push(_id);\n    } //end fun \n\n    /**\n    * @dev check if indexes contains an ID\n    * @param _indexName eg. toBytes32('OFFERS_BY_COUNTRY');\n    * @param _key eg. us (country code)\n    * @param _id the offer Id \n    */\n    function indexesHasId(bytes32 _indexName, bytes32 _key, uint256 _id) public view returns(bool) {\n        return false;\n    }\n\n    /**\n     * getRating\n     */\n    function getOfferRating(uint256 offerId) public view returns (uint) {\n        return OfferRatings[offerId];\n    }\n\n    /**\n     * setOfferRating\n     */\n    function setOfferRating(uint256 offerId, uint rating) public onlyStoreEditor {\n        OfferRatings[offerId] = rating;\n    }\n\n} //end contract"
    },
    "contracts/Storage/AssetsStore.sol": {
      "content": "/*\n* LibertyPie Project (https://libertypie.com)\n* @author https://github.com/libertypie (hello@libertypie.com)\n* @license SPDX-License-Identifier: MIT\n*/\npragma solidity ^0.7.6;\npragma experimental ABIEncoderV2;\nimport \"./StoreEditor.sol\";\nimport \"../Commons/AssetsStructs.sol\";\n\n\ncontract AssetsStore is StoreEditor  {\n\n    //set initially at 0, \n    //0 index wont be used due  to solidity behaviour over non existent data\n    uint256  private totalAssets;\n    \n    /**\n     * @dev mapping for  assetsData \n     */\n    mapping(uint256 => AssetsStructs.AssetItem) private  AssetsData;\n\n    // assetsDataIndexes \n    // format mapping(assetContractAddress  => index )\n    mapping(address => uint256) private AssetsDataIndexes;\n\n\n    /**\n     * get the next asset id\n     */\n    function getNextAssetId() external onlyStoreEditor returns(uint256) {\n        return (++totalAssets);\n    }\n\n    /**\n     * get total assets\n     */\n    function getTotalAssets() external view returns (uint256) {\n        return totalAssets;\n    }\n\n    /**\n     * @dev saveAssetData\n     * @param _id asset id\n     * @param _data asset data \n     */\n    function saveAssetData(uint256 _id, AssetsStructs.AssetItem memory _data) external onlyStoreEditor {\n        AssetsData[_id] = _data;\n        AssetsDataIndexes[_data.contractAddress] = _id;\n    } //end fun \n\n\n    /**\n     * @dev get asset data\n     * @param _id asset id\n     */\n    function getAssetData(uint256 _id) external view returns(AssetsStructs.AssetItem memory) {\n        return AssetsData[_id];\n    } //end fun \n\n\n    /**\n     * @dev get assetData by address\n     */\n    function getAssetIdByAddress(address _address) public view returns (uint256) {\n        return AssetsDataIndexes[_address];\n    } //end fun \n    \n    /**\n    * @dev getAssetDataByAddress\n    * @param _address asset address\n    */\n    function getAssetDataByAddress(address _address) external view returns (AssetsStructs.AssetItem memory) {\n        return AssetsData[getAssetIdByAddress(_address)];\n    }\n    \n}\n"
    },
    "contracts/Storage/ConfigStore.sol": {
      "content": "/*\n* LibertyPie Project (https://libertypie.com)\n* @author https://github.com/libertypie (hello@libertypie.com)\n* @license SPDX-License-Identifier: MIT\n*/\npragma solidity ^0.7.6;\npragma experimental ABIEncoderV2;\nimport \"./StoreEditor.sol\";\nimport \"../Commons/ConfigsStructs.sol\";\n\ncontract ConfigStore is StoreEditor  {\n\n    //total Config\n    uint256 public totalEntries;\n\n    //config \n    mapping(string => bytes32) private configData;\n    \n    //config indexes\n    mapping(uint256 => string) private configKeyMap;\n\n    \n    /**\n     * @dev get config data\n     * @param _key a byte32 key\n     */\n    function getConfigData(string memory _key) public view returns (bytes32){\n        return configData[_key];\n    }\n\n    /**\n     * @dev get all config data\n     */\n    function addConfigData(string memory _key, bytes32 _value) external onlyStoreEditor {\n        configData[_key] = _value;\n        configKeyMap[++totalEntries] = _key;\n    } //end fun\n\n\n    /**\n    * allConfigData\n    */\n    function getAllConfigData() public view returns (ConfigsStructs.ConfigItem[] memory) {\n        \n\n       ConfigsStructs.ConfigItem[]  memory configsArray = new ConfigsStructs.ConfigItem[](totalEntries + 1);\n\n        for(uint256 i = 1; i <= totalEntries; i++){\n            string memory _key = configKeyMap[i];\n            if(bytes(_key).length > 0){ configsArray[i] = ConfigsStructs.ConfigItem(_key,configData[_key]); }\n        }\n\n        return configsArray;\n    } //end fun\n\n    \n}"
    },
    "contracts/Storage/TradesStore.sol": {
      "content": "/*\n* LibertyPie Project (https://libertypie.com)\n* @author https://github.com/libertypie (hello@libertypie.com)\n* @license SPDX-License-Identifier: MIT\n*/\npragma solidity ^0.7.6;\npragma experimental ABIEncoderV2;\nimport \"./StoreEditor.sol\";\nimport \"../Commons/TradesStructs.sol\";\n\n\ncontract TradesStore is StoreEditor  {\n\n    //total trades\n    uint256 totalTrades;\n\n    //Trades \n    mapping(uint256 => TradesStructs.TradeInfo) private Trades;\n\n\n    /**\n     * @dev get next TradeId\n     */\n     function getNextTradeId() external onlyStoreEditor returns(uint256) {\n        return (++totalTrades);\n     }\n\n    /**\n     * getTotalTrades\n     */\n    function getTotalTrades() external view  returns (uint256){\n        return totalTrades;\n    }\n\n    /**\n     * getTrade\n     */\n    function getTrade(uint256 _id) public view returns(TradesStructs.TradeInfo memory) {\n        return Trades[_id];\n    }\n\n    /**\n     * saveTradeInfo\n     */\n     function saveTradeInfo(uint256 _id, TradesStructs.TradeInfo memory _tradeInfo) public onlyStoreEditor {\n        Trades[_id] = _tradeInfo;\n     } //end fun \n}"
    },
    "contracts/Commons/TradesStructs.sol": {
      "content": "/*\n* LibertyPie Project (https://libertypie.com)\n* @author https://github.com/libertypie (hello@libertypie.com)\n* @license SPDX-License-Identifier: MIT\n*/\npragma solidity ^0.7.6;\npragma experimental ABIEncoderV2;\n\n/**\n * @dev offer struct Implementation\n */\ncontract TradesStructs {\n\n    struct TradeInfo {\n       uint256   id; \n       uint256   offerId;\n       uint256   amount;\n       address   asset;\n       address   tradePartner;\n       address   tradeGuardian;\n       uint256   createdAt;\n       uint256   expiresAt;\n       bool   isSuccess; \n    }\n\n\n    struct TradeReview{\n        uint256 id;\n        uint256 tradeId;\n        uint256 offerId;\n        uint256 partnerRating;\n        string  partnerCommentHash;\n        uint256 guardianRating;\n        string  guardianCommentHash;\n        uint256 createdAt;\n        uint256 updatedAt; \n    }\n\n} //end contract"
    },
    "contracts/Factory.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.7.6;\npragma experimental ABIEncoderV2;\n\nimport \"./PriceFeeds/PriceFeed.sol\";\nimport \"./Assets.sol\";\n//mport \"./PermissionManager/PM.sol\";\n\nimport \"./PaymentMethods.sol\";\n\n//import \"./Config.sol\";\n\n//import \"./Storage/DataStore.sol\";\n\n\ncontract Factory is  PaymentMethods, PriceFeed, Assets {\n    \n    constructor(\n        address _permissionManagerContract,\n        address _storageContract\n    ) {\n\n        //lets initialize pm \n        initializePermissionManager(_permissionManagerContract);\n\n        //initialize data store \n        initializeDataStore(_storageContract);\n\n    } //end fun \n\n\n} //end contract"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}